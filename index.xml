<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Luís Franco</title><link>https://ornlu-is.github.io/</link><description>This is my cool site</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 16 Aug 2023 21:37:47 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Go build tags for defining sets of tests</title><link>https://ornlu-is.github.io/go_build_tags/</link><pubDate>Wed, 16 Aug 2023 21:37:47 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_build_tags/</guid><description>Some time ago, I was looking for a way to define a clear separation in a Go project between my unit tests and my integration tests. At the time, the solution I came up with involved creating a submodule and some Makefile shenanigans to separate these into two sets. I was unhappy with this approach, since it ended up being convoluted and prone to error as the code base evolved. However, today I recently learned about Go&amp;rsquo;s build tags that seemlessly allow me to separate my integration tests from my unit tests.</description></item><item><title>Kubernetes deploy job failed but the service was deployed</title><link>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</link><pubDate>Tue, 15 Aug 2023 19:49:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</guid><description>A while back, I was investigating a bug where my deployment job had failed, but the service had been deployed. At first I thought this was weird, afterwards I thought this was extremely concerning: had this happened before and I was just noticing now by accident? Since I did not want to have failed deployment jobs actually deploying my services, I took a closer look at this issue.
The situation What happened was pretty simple.</description></item><item><title>A deep dive on Golang slices</title><link>https://ornlu-is.github.io/go_slices/</link><pubDate>Mon, 14 Aug 2023 21:50:02 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_slices/</guid><description>Slices are Go&amp;rsquo;s bread and butter. However, more often than not, small mistakes happen because it isn&amp;rsquo;t exactly clear what actually is a slice. Since they are so prevalent in Go code, I decided to dive a bit deeper into their internal structure, how they are handled in different situations, and how some of the issues that arise can be avoided.
But first, arrays Before diving into slices, it is important to know that Go also has the concept of arrays.</description></item><item><title>Understanding Netflow v5</title><link>https://ornlu-is.github.io/netflow_v5/</link><pubDate>Sun, 13 Aug 2023 18:54:40 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/netflow_v5/</guid><description>NetFlow is a protocol developed by Cisco that has had several iterations over the years. This network protocol&amp;rsquo;s main focus is to collect IP traffic information and export it for monitoring purposes. A router configured to collect NetFlow will aggregate data packets into what is known as a flow, which is basically a summary of the traffic passing through the device in a given time span. Of the multiple iterations of the NetFlow protocol that Cisco has produced, two have cemented themselves as the most commonly used protocols: NetFlow v5 and NetFlow v9.</description></item><item><title>Hooking Promtail, Loki, and Grafana to your Docker Compose stack</title><link>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</link><pubDate>Fri, 11 Aug 2023 11:46:41 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</guid><description>When testing software locally, one of the main tools at a software engineer&amp;rsquo;s disposal is Docker, more particularly, the Docker Compose tool. This tool allows engineers to define and run a multi-container setup using YAML files. The vast majority of software produces a form of output known as logs, which provide information on what is happening in a running application, such as errors, possible warnings, general information, and more.
The issue with inspecting Docker Compose log messages When you run a Docker Compose setup locally, you&amp;rsquo;ll usually see all container logs being printed in rapid succession in your terminal, and, depending on the amount of logs your multi-container stack produces, this might be very difficult to navigate, reason about, and correlate log messages from different containers.</description></item><item><title>Hassle-free table creation on start up for Clickhouse Docker containers</title><link>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</link><pubDate>Mon, 07 Aug 2023 19:56:16 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</guid><description>This is a neat little trick I learned recently. I was in need of creating a Clickhouse container to attach to another application that would write to it. And I found myself thinking: it would be really convenient if there were a way to create a Clickhouse container that already comes with a set of tables created. Most of the solutions I found only were severely convoluted and relied on scripts to make this happen, so I thought that there must surely be a better way.</description></item><item><title>A pre-commit git hook for running Go unit tests</title><link>https://ornlu-is.github.io/git_hooks_for_go/</link><pubDate>Mon, 31 Jul 2023 19:50:06 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/git_hooks_for_go/</guid><description>I mostly code in Go, which comes with the handy go tool. This tool has a bunch of functionalities with one of the most important (at least for me) being the ability to run tests. I love writing tests for my code because I hate being paged when I am on call. However, whenever I open a PR, sometimes I forget to run the tests locally before pushing my code and then my code ends up failing the CI builds, which overall results in a slower development process.</description></item><item><title>CIDRs and how they are handled by different systems</title><link>https://ornlu-is.github.io/go_postgres_cidr_mismatch/</link><pubDate>Sun, 30 Jul 2023 16:37:43 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_postgres_cidr_mismatch/</guid><description>I came across an interesting bug in the past few days. I had a very simple Go program that had a single purpose: it would take some user input, process that input, and then write it to a database. However, the program would sometimes fail, when given input that apparently was valid. And I thought that this bug was interesting enough to write about it, so here we are.
Understanding CIDR notation Before diving into the actual bug, it is fundamental that we understand CIDR notation.</description></item><item><title>Detecting Vulnerabilities in Go Code</title><link>https://ornlu-is.github.io/go_detecting_vulnerabilities/</link><pubDate>Tue, 25 Jul 2023 22:29:46 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_detecting_vulnerabilities/</guid><description>When writing software, one might, accidentally (or not), ship the software with vulnerabilities, which are broadly defined as flaws or weaknesses in code that can be exploited by an attacker. We do not want to have those in our Go code so we need some way of minimizing the number of vulnerabilities our code has. Fortunately there are tools built by the Go community and team that can be leveraged for this.</description></item><item><title>Go Design Patterns: Functional Options</title><link>https://ornlu-is.github.io/go_design_pattern_functional_options/</link><pubDate>Thu, 20 Jul 2023 22:19:24 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_design_pattern_functional_options/</guid><description>The Functional Options pattern is a rather elegant manner of implementing a Golang struct constructor that allows for custom default values, which means that users of the API we are implementing will only need to specify the struct attribute values that the users deem that shouldn&amp;rsquo;t take their default values.
For our example, let us consider the very simple use case where we have a package named person containing a Person struct, which will look like this:</description></item></channel></rss>