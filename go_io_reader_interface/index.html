<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-G300HG9GRT"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G300HG9GRT")</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Why does Go's io.Reader interface take a slice of bytes as argument? - Luís Franco</title><meta name=Description content="Why io.Reader interface takes a byte slice instead of returning a byte slice"><meta property="og:title" content="Why does Go's io.Reader interface take a slice of bytes as argument?">
<meta property="og:description" content="Why io.Reader interface takes a byte slice instead of returning a byte slice"><meta property="og:type" content="article"><meta property="og:url" content="https://ornlu-is.github.io/go_io_reader_interface/"><meta property="og:image" content="https://ornlu-is.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-22T19:19:47+01:00"><meta property="article:modified_time" content="2023-08-22T22:06:26+01:00"><meta property="og:site_name" content="Super website"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ornlu-is.github.io/logo.png"><meta name=twitter:title content="Why does Go's io.Reader interface take a slice of bytes as argument?"><meta name=twitter:description content="Why io.Reader interface takes a byte slice instead of returning a byte slice"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://ornlu-is.github.io/go_io_reader_interface/><link rel=prev href=https://ornlu-is.github.io/go_tee_channel_pattern/><link rel=next href=https://ornlu-is.github.io/overengineering_1/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Why does Go's io.Reader interface take a slice of bytes as argument?","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ornlu-is.github.io\/go_io_reader_interface\/"},"genre":"posts","wordcount":1022,"url":"https:\/\/ornlu-is.github.io\/go_io_reader_interface\/","datePublished":"2023-08-22T19:19:47+01:00","dateModified":"2023-08-22T22:06:26+01:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Luís Franco"},"description":"Why io.Reader interface takes a byte slice instead of returning a byte slice"}</script></head><body data-header-desktop=auto data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Luís Franco">Luís Franco</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/about/>About </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></span></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Luís Franco">Luís Franco</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/about/ title>About</a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Why does Go's io.Reader interface take a slice of bytes as argument?</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Luís Franco</a>
</span>&nbsp;<span class=post-category>included in <a href=/categories/golang/><i class="far fa-folder fa-fw" aria-hidden=true></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-08-22>2023-08-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1022 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;5 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#the-ioreader-interface>The <code>io.Reader</code> interface</a></li><li><a href=#stack-and-heap-memory-in-go>Stack and Heap memory in Go</a></li><li><a href=#a-worked-example>A worked example</a></li><li><a href=#so-why-does-ioreaderread-receive-a-byte-slice-as-argument>So why does <code>io.Reader.Read</code> receive a byte slice as argument?</a></li><li><a href=#final-note>Final note</a></li></ul></nav></div></div><div class=content id=content><p>I rencetly watched a GopherCon talk titled &ldquo;Understanding Allocations: The Stack and the Heap&rdquo; by Jacob Walker, and found it really interesting, especially the final conclusion on why the <code>io.Reader</code> interface is the way it is. As it turns out, it is related to how memory allocation works in Go. More specifically, where the memory is allocated.</p><h2 id=the-ioreader-interface>The <code>io.Reader</code> interface</h2><p>There isn&rsquo;t much to say here, everyone that has been programming in Go has surely found this interface out in the wild multiple times, and it looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>But why does it return the number of bytes read instead of returning a slice of bytes? It would make sense that if I tell something to read, it would just give me what it read, instead of requiring me to allocate a slice where it will write to. To understand this, we have to go on a little detour.</p><h2 id=stack-and-heap-memory-in-go>Stack and Heap memory in Go</h2><p>Broadly speaking, there are two places where variables can be allocated in your Go program. There is the heap, and then there are the stacks, usually one for each goroutine that exists. For the purpose of this post, the main difference between a stack and a heap, is that whatever is in the heap eventually gets garbage collected.</p><p>This prompts one immediate question: where will my variables be allocated? In essence, there is no way of knowing this while you are writing code, only the compiler can answer this. However, there are some instances where your variables are <strong>typically</strong> written to the heap. <strong>Usually</strong>, whatever is shared down, <em>i.e.</em>, passing pointers to things, stays on the stack and whatever is shared up, <em>i.e.</em>, returning pointers, references, or things with pointers in them, tends to go on the heap. Additionally, there are some more use cases where memory is <strong>typically</strong> allocated on the heap:</p><ul><li>When a value could possibly be referenced after the function that constructed the value returns;</li><li>When the value is too large to fit on the stack;</li><li>When the size of a value is unknown at compile time;</li><li>When values are shared with pointers;</li><li>When variables are stored in interface variables;</li><li>When variables store anonymous functions, or are variables captured by a closure.</li></ul><p>Again, this is <strong>usually</strong>, only the compiler really knows where stuff gets allocated.</p><h2 id=a-worked-example>A worked example</h2><p>Let us look at a practical example. Below I have a simple piece of code, with a <code>main</code> function that calls the function <code>read</code>, assigns its return value to a variable, and then prints it out using <code>println</code> (using <code>fmt.Println</code> will yield different results). The <code>read</code> function creates a slice of two bytes, assigns a value to each of those, and then returns it.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>read</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=nf>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nb>println</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>So what is going on the heap and what is staying in the stack? We can investigate this by passing some flags to our <code>go build</code> command. When we use the <code>go build</code> tool, the underlying tool is the <code>compile</code> tool. And since we are looking for a flag that allows us to investigate what optimisation decisions are being performed by the compiler, we look for those flags using <code>go tool compile -h</code>, which uncovers the following suspect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>-m	print optimization decisions
</span></span></code></pre></td></tr></table></div></div><p>Nice, we&rsquo;ve found what we were looking for. Running <code>go build -gcflags "-m"</code> in our directory gives us the following output:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>./main.go:3:6: can inline read
</span></span><span class=line><span class=cl>./main.go:10:6: can inline main
</span></span><span class=line><span class=cl>./main.go:11:11: inlining call to read
</span></span><span class=line><span class=cl>./main.go:4:11: make([]byte, 2) escapes to heap
</span></span><span class=line><span class=cl>./main.go:11:11: make([]byte, 2) does not escape
</span></span></code></pre></td></tr></table></div></div><p>From the fourth of the output, we can see that, in line 4 of our code, the variable allocated has been allocated to the heap. Why?</p><p>On line 4, we are creating a slice of bytes inside the function <code>read</code>. A slice is essentially a pointer to an underlying array, and two integers, thus, when the function <code>read</code> returns and assigns its return value to <code>b</code>, we now have two pointers to the same memory position. However, the pointer created inside <code>read</code> cannot be used by anything in our code, it is unreachable. As such, it is garbage and must be garbage collected. Hence, it goes on the heap.</p><p>So what happens if, instead of having our <code>read</code> function create and return a slice of bytes, we have it receive a slice of bytes as argument and populate it with data? For that purpose, I wrote the following program:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>read</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>println</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>For which we have to following output of the optimisation decisions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>./main.go:3:6: can inline read
</span></span><span class=line><span class=cl>./main.go:8:6: can inline main
</span></span><span class=line><span class=cl>./main.go:10:6: inlining call to read
</span></span><span class=line><span class=cl>./main.go:3:11: b does not escape
</span></span><span class=line><span class=cl>./main.go:9:11: make([]byte, 2) does not escape
</span></span></code></pre></td></tr></table></div></div><p>In line 3, <code>b</code> does not escape because it is a copy of the slice defined in the <code>main</code> function, which means that it is a copy of the pointer (and two integers for the slice capacity and length), not of the underlying array, that allocation has already been performed in <code>main</code>.</p><h2 id=so-why-does-ioreaderread-receive-a-byte-slice-as-argument>So why does <code>io.Reader.Read</code> receive a byte slice as argument?</h2><p>Now we are ready to answer this question. And the answer is extremely simple: because if it returned a slice of bytes instead, a lot more garbage collection would have to be performed and this would result in increased latency.</p><h2 id=final-note>Final note</h2><p>Please do not write your program with the mindset of minimizing how much stuff gets written into the heap. Strive for correctness and readability, and only go for this type of optimisation if you require your program to go faster and you have data to support your hypothesis that latency is being caused by garbage collection.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-08-22</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/go_tee_channel_pattern/ class=prev rel=prev title="Go Concurrency Patterns: Tee Channel"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Go Concurrency Patterns: Tee Channel</a>
<a href=/overengineering_1/ class=next rel=next title="Adventures in Overengineering 1: Inventory">Adventures in Overengineering 1: Inventory<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Luís Franco</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>