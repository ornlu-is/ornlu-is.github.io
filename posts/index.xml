<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - Luís Franco</title><link>https://ornlu-is.github.io/posts/</link><description>All Posts | Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 21 Aug 2023 19:39:39 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Go Concurrency Patterns: Tee Channel</title><link>https://ornlu-is.github.io/go_tee_channel_pattern/</link><pubDate>Mon, 21 Aug 2023 19:39:39 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_tee_channel_pattern/</guid><description>If you&amp;rsquo;ve ever used the Linux tee command, you can probably guess what this pattern is about. At a first glance, this might seem similar to the fan-out concurrency pattern and, in a way, it is. But there is one crucial difference. The fan-out concurrency pattern splits the input from one channel into several channels for concurrent processing, while the tee channel pattern creates two channels with the exact same data as the original one.</description></item><item><title>Go Concurrency Patterns: Pipeline</title><link>https://ornlu-is.github.io/go_pipeline_pattern/</link><pubDate>Mon, 21 Aug 2023 16:24:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_pipeline_pattern/</guid><description>Yet another Go concurrency pattern! This particular pattern is extremely helpful in composing several transformations from data incoming from a stream, and is know as the pipeline concurrency pattern. In a pipeline, we define several stages, which are nothing more than objects that take data in, perform some operation on it, and then output the transformed data.
Link to the code https://github.com/ornlu-is/go_pipeline_pattern The Pipeline pattern in Go Pipeline pattern Translating the above definition to Go, the pipeline pattern is simply a function that takes a channel, performs some operation on the data from that channel, and outputs it to another channel.</description></item><item><title>Go Concurrency Patterns: Fan-Out</title><link>https://ornlu-is.github.io/go_fan_out_pattern/</link><pubDate>Mon, 21 Aug 2023 14:40:12 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_fan_out_pattern/</guid><description>I have written a blog post about the fan-in concurrency pattern and, unlike most texts on this matter, I left its counterpart, the fan-out concurrency pattern, to have its own post. While these two patterns are mostly used in tandem, I believe that it is fundamental to understand them separately, so as to not create any mental blockers that would coherce us to only use one pattern when the other is also required.</description></item><item><title>Go Concurrency Patterns: Fan-In</title><link>https://ornlu-is.github.io/go_fan_in_pattern/</link><pubDate>Mon, 21 Aug 2023 09:38:20 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_fan_in_pattern/</guid><description>It is not uncommon to have a piece of software that is concurrently reading from multiple streams of data. However, for a multitude of possible reasons, we might want to aggregate these streams into a single one, for example, to send the data to another service. Fortunately, this is not a new problem, and the solution for it is well known as the Fan-In pattern.
Link to the code https://github.com/ornlu-is/go_fan_in_pattern The Fan-In pattern in Go Fan-In pattern As stated before, the idea behind this is incredibly simple: the fan-in pattern combines several data streams into one.</description></item><item><title>Enforcing test coverage in Go with Makefile</title><link>https://ornlu-is.github.io/go_makefile_code_coverage/</link><pubDate>Thu, 17 Aug 2023 23:22:19 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_makefile_code_coverage/</guid><description>Makefiles are a popular way of making the development process easier, since they can be used to chain several commands that allow developers to build, test, run, etc. their code. Additionally, they can also be used to create a make-based build/test system. In this post, I&amp;rsquo;m going to cover something how to set up a Makefile rule to test Golang code and enforce test coverage, i.e., have the rule fail if a predefined test coverage threshold is not met.</description></item><item><title>Go Design Patterns: Generator</title><link>https://ornlu-is.github.io/go_design_pattern_generator/</link><pubDate>Thu, 17 Aug 2023 22:13:52 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_design_pattern_generator/</guid><description>I like the generator pattern. I hadn&amp;rsquo;t realized it, but I had already encountered this pattern before when I used to program in Python. I recently found myself requiring to loop over a large sequence of numbers. Naively, I created a slice with all the values I required and then I looped over them. However, I was not satisfied with this solution so I went digging and found the generator pattern.</description></item><item><title>Using Go build tags for defining sets of tests</title><link>https://ornlu-is.github.io/go_build_tags/</link><pubDate>Wed, 16 Aug 2023 21:37:47 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_build_tags/</guid><description>Some time ago, I was looking for a way to define a clear separation in a Go project between my unit tests and my integration tests. At the time, the solution I came up with involved creating a submodule and some Makefile shenanigans to separate these into two sets. I was unhappy with this approach, since it ended up being convoluted and prone to error as the code base evolved. However, today I recently learned about Go&amp;rsquo;s build tags that seemlessly allow me to separate my integration tests from my unit tests.</description></item><item><title>Kubernetes deploy job failed but the service was deployed</title><link>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</link><pubDate>Tue, 15 Aug 2023 19:49:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</guid><description>A while back, I was investigating a bug where my deployment job had failed, but the service had been deployed. At first I thought this was weird, afterwards I thought this was extremely concerning: had this happened before and I was just noticing now by accident? Since I did not want to have failed deployment jobs actually deploying my services, I took a closer look at this issue.
The situation What happened was pretty simple.</description></item><item><title>A deep dive on Golang slices</title><link>https://ornlu-is.github.io/go_slices/</link><pubDate>Mon, 14 Aug 2023 21:50:02 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_slices/</guid><description>Slices are Go&amp;rsquo;s bread and butter. However, more often than not, small mistakes happen because it isn&amp;rsquo;t exactly clear what actually is a slice. Since they are so prevalent in Go code, I decided to dive a bit deeper into their internal structure, how they are handled in different situations, and how some of the issues that arise can be avoided.
But first, arrays Before diving into slices, it is important to know that Go also has the concept of arrays.</description></item><item><title>Understanding Netflow v5</title><link>https://ornlu-is.github.io/netflow_v5/</link><pubDate>Sun, 13 Aug 2023 18:54:40 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/netflow_v5/</guid><description>NetFlow is a protocol developed by Cisco that has had several iterations over the years. This network protocol&amp;rsquo;s main focus is to collect IP traffic information and export it for monitoring purposes. A router configured to collect NetFlow will aggregate data packets into what is known as a flow, which is basically a summary of the traffic passing through the device in a given time span. Of the multiple iterations of the NetFlow protocol that Cisco has produced, two have cemented themselves as the most commonly used protocols: NetFlow v5 and NetFlow v9.</description></item></channel></rss>