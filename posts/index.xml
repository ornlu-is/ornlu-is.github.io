<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - Luís Franco</title><link>https://ornlu-is.github.io/posts/</link><description>All Posts | Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 21 Aug 2023 14:40:12 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Go Concurrency Patterns: Fan-Out</title><link>https://ornlu-is.github.io/go_fan_out_pattern/</link><pubDate>Mon, 21 Aug 2023 14:40:12 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_fan_out_pattern/</guid><description>I have written a blog post about the fan-in concurrency pattern and, unlike most texts on this matter, I left its counterpart, the fan-out concurrency pattern, to have its own post. While these two patterns are mostly used in tandem, I believe that it is fundamental to understand them separately, so as to not create any mental blockers that would coherce us to only use one pattern when the other is also required.</description></item><item><title>Go Concurrency Patterns: Fan-In</title><link>https://ornlu-is.github.io/go_fan_in_pattern/</link><pubDate>Mon, 21 Aug 2023 09:38:20 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_fan_in_pattern/</guid><description>It is not uncommon to have a piece of software that is concurrently reading from multiple streams of data. However, for a multitude of possible reasons, we might want to aggregate these streams into a single one, for example, to send the data to another service. Fortunately, this is not a new problem, and the solution for it is well known as the Fan-In pattern.
Link to the code https://github.com/ornlu-is/go_fan_in_pattern The Fan-In pattern in Go Fan-In pattern As stated before, the idea behind this is incredibly simple: the fan-in pattern combines several data streams into one.</description></item><item><title>Enforcing test coverage in Go with Makefile</title><link>https://ornlu-is.github.io/go_makefile_code_coverage/</link><pubDate>Thu, 17 Aug 2023 23:22:19 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_makefile_code_coverage/</guid><description>Makefiles are a popular way of making the development process easier, since they can be used to chain several commands that allow developers to build, test, run, etc. their code. Additionally, they can also be used to create a make-based build/test system. In this post, I&amp;rsquo;m going to cover something how to set up a Makefile rule to test Golang code and enforce test coverage, i.e., have the rule fail if a predefined test coverage threshold is not met.</description></item><item><title>Go Design Patterns: Generator</title><link>https://ornlu-is.github.io/go_design_pattern_generator/</link><pubDate>Thu, 17 Aug 2023 22:13:52 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_design_pattern_generator/</guid><description>I like the generator pattern. I hadn&amp;rsquo;t realized it, but I had already encountered this pattern before when I used to program in Python. I recently found myself requiring to loop over a large sequence of numbers. Naively, I created a slice with all the values I required and then I looped over them. However, I was not satisfied with this solution so I went digging and found the generator pattern.</description></item><item><title>Using Go build tags for defining sets of tests</title><link>https://ornlu-is.github.io/go_build_tags/</link><pubDate>Wed, 16 Aug 2023 21:37:47 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_build_tags/</guid><description>Some time ago, I was looking for a way to define a clear separation in a Go project between my unit tests and my integration tests. At the time, the solution I came up with involved creating a submodule and some Makefile shenanigans to separate these into two sets. I was unhappy with this approach, since it ended up being convoluted and prone to error as the code base evolved. However, today I recently learned about Go&amp;rsquo;s build tags that seemlessly allow me to separate my integration tests from my unit tests.</description></item><item><title>Kubernetes deploy job failed but the service was deployed</title><link>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</link><pubDate>Tue, 15 Aug 2023 19:49:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/</guid><description>A while back, I was investigating a bug where my deployment job had failed, but the service had been deployed. At first I thought this was weird, afterwards I thought this was extremely concerning: had this happened before and I was just noticing now by accident? Since I did not want to have failed deployment jobs actually deploying my services, I took a closer look at this issue.
The situation What happened was pretty simple.</description></item><item><title>A deep dive on Golang slices</title><link>https://ornlu-is.github.io/go_slices/</link><pubDate>Mon, 14 Aug 2023 21:50:02 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_slices/</guid><description>Slices are Go&amp;rsquo;s bread and butter. However, more often than not, small mistakes happen because it isn&amp;rsquo;t exactly clear what actually is a slice. Since they are so prevalent in Go code, I decided to dive a bit deeper into their internal structure, how they are handled in different situations, and how some of the issues that arise can be avoided.
But first, arrays Before diving into slices, it is important to know that Go also has the concept of arrays.</description></item><item><title>Understanding Netflow v5</title><link>https://ornlu-is.github.io/netflow_v5/</link><pubDate>Sun, 13 Aug 2023 18:54:40 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/netflow_v5/</guid><description>NetFlow is a protocol developed by Cisco that has had several iterations over the years. This network protocol&amp;rsquo;s main focus is to collect IP traffic information and export it for monitoring purposes. A router configured to collect NetFlow will aggregate data packets into what is known as a flow, which is basically a summary of the traffic passing through the device in a given time span. Of the multiple iterations of the NetFlow protocol that Cisco has produced, two have cemented themselves as the most commonly used protocols: NetFlow v5 and NetFlow v9.</description></item><item><title>Hooking Promtail, Loki, and Grafana to your Docker Compose stack</title><link>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</link><pubDate>Fri, 11 Aug 2023 11:46:41 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</guid><description>When testing software locally, one of the main tools at a software engineer&amp;rsquo;s disposal is Docker, more particularly, the Docker Compose tool. This tool allows engineers to define and run a multi-container setup using YAML files. The vast majority of software produces a form of output known as logs, which provide information on what is happening in a running application, such as errors, possible warnings, general information, and more.
The issue with inspecting Docker Compose log messages When you run a Docker Compose setup locally, you&amp;rsquo;ll usually see all container logs being printed in rapid succession in your terminal, and, depending on the amount of logs your multi-container stack produces, this might be very difficult to navigate, reason about, and correlate log messages from different containers.</description></item><item><title>Hassle-free table creation on start up for Clickhouse Docker containers</title><link>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</link><pubDate>Mon, 07 Aug 2023 19:56:16 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</guid><description>This is a neat little trick I learned recently. I was in need of creating a Clickhouse container to attach to another application that would write to it. And I found myself thinking: it would be really convenient if there were a way to create a Clickhouse container that already comes with a set of tables created. Most of the solutions I found only were severely convoluted and relied on scripts to make this happen, so I thought that there must surely be a better way.</description></item></channel></rss>