<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - Luís Franco</title><link>https://ornlu-is.github.io/posts/</link><description>All Posts | Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 12 Nov 2023 20:46:31 +0000</lastBuildDate><atom:link href="https://ornlu-is.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Study Notes 1: A bird's-eye view of a Kubernetes cluster</title><link>https://ornlu-is.github.io/kubernetes_architecture_overview/</link><pubDate>Sun, 12 Nov 2023 20:46:31 +0000</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/kubernetes_architecture_overview/</guid><description>I&amp;rsquo;ve been meaning to do this for a while now. I&amp;rsquo;ve studied quite a Kubernetes in the past year and have a ton of handwritten notes that I want to throw away, so I&amp;rsquo;m transfering all of those notes into my blog. This is also a great review opportunity (and also has the added advantage that I will stop needing to comb through endless sheets of paper when I want to remember something).</description></item><item><title>Adventures in Overengineering 5: Monitoring Raspberry Pi Machines with Prometheus and Grafana</title><link>https://ornlu-is.github.io/overengineering_5/</link><pubDate>Mon, 30 Oct 2023 10:46:29 +0000</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/overengineering_5/</guid><description>With Node Exporter installed in each of the Raspberry Pi machines, I can now start scraping these metrics and actually using them to build a dashboard to monitor my machines. And this is also the step in which I create a GitHub repository where all scripts and configuration files used are stored, just in case my laptop decides to perish a second time and I have to go through this all over again (RIP my old SSD).</description></item><item><title>Adventures in Overengineering 4: Installing Node Exporter via Salt</title><link>https://ornlu-is.github.io/overengineering_4/</link><pubDate>Sat, 28 Oct 2023 13:49:05 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/overengineering_4/</guid><description>I have a bunch of physical machines and it is important to keep track of how healthy these machines are. More specifically, I want to keep track of some key metrics such as how much CPU or memory is being used and disk space. Additionally, I also want to keep track of the temperature of these machines because I do not want to accidentally burn down my house (that would really destroy the budget for this project).</description></item><item><title>Adventures in Overengineering 3: Installing Salt to manage Raspberry Pi machines</title><link>https://ornlu-is.github.io/overengineering_3/</link><pubDate>Tue, 10 Oct 2023 19:36:10 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/overengineering_3/</guid><description>I have three machines with Ubuntu installs up and running but there is one thing that I really want to avoid: having to ssh into them to install software, since the effort of installing a given package/software is always multiplied by three. As such, I thought this was an appropriate time to refresh my Salt knowledge, which is an event-driven framework/automation tool whose name probably derives from the high blood pressure it induces whenever it is used to perform changes on production environment machines.</description></item><item><title>Adventures in Overengineering 2: Installing an Operating System</title><link>https://ornlu-is.github.io/overengineering_2/</link><pubDate>Thu, 28 Sep 2023 21:40:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/overengineering_2/</guid><description>Now that I have some hardware available, I need to install an operating system on these machines so that I can then install some software that will enable me to actually do something with these things. Since I do not want to have to connect a monitor to these machines every time I need to use them, I also have to set up some type of remote access.
Other posts in this series Adventures in Overengineering 1: Inventory Adventures in Overengineering 3: Installing Salt to manage Raspberry Pi machines Adventures in Overengineering 4: Installing Node Exporter via Salt Adventures in Overengineering 5: Monitoring Raspberry Pi Machines with Prometheus and Grafana Preparing the microSD cards This part is extremely simple.</description></item><item><title>Adventures in Overengineering 1: Inventory</title><link>https://ornlu-is.github.io/overengineering_1/</link><pubDate>Thu, 28 Sep 2023 16:17:45 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/overengineering_1/</guid><description>A few months ago, I started a series of posts about my attempt to completely overengineer a simple Go web server. After a few posts, I had to archive that series. I was not pleased with the result, it wasn&amp;rsquo;t&amp;hellip; enough. Last time, I began this adventure by running a Kubernetes instance on my laptop. This time, I&amp;rsquo;ve gone deeper into the overengineering madness. Keep in mind that the end goal is still to deploy a very basic Golang web server.</description></item><item><title>Why does Go's io.Reader interface take a slice of bytes as argument?</title><link>https://ornlu-is.github.io/go_io_reader_interface/</link><pubDate>Tue, 22 Aug 2023 19:19:47 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_io_reader_interface/</guid><description>I rencetly watched a GopherCon talk titled &amp;ldquo;Understanding Allocations: The Stack and the Heap&amp;rdquo; by Jacob Walker, and found it really interesting, especially the final conclusion on why the io.Reader interface is the way it is. As it turns out, it is related to how memory allocation works in Go. More specifically, where the memory is allocated.
The io.Reader interface There isn&amp;rsquo;t much to say here, everyone that has been programming in Go has surely found this interface out in the wild multiple times, and it looks like this:</description></item><item><title>Go Concurrency Patterns: Tee Channel</title><link>https://ornlu-is.github.io/go_tee_channel_pattern/</link><pubDate>Mon, 21 Aug 2023 19:39:39 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_tee_channel_pattern/</guid><description>If you&amp;rsquo;ve ever used the Linux tee command, you can probably guess what this pattern is about. At a first glance, this might seem similar to the fan-out concurrency pattern and, in a way, it is. But there is one crucial difference. The fan-out concurrency pattern splits the input from one channel into several channels for concurrent processing, while the tee channel pattern creates two channels with the exact same data as the original one.</description></item><item><title>Go Concurrency Patterns: Pipeline</title><link>https://ornlu-is.github.io/go_pipeline_pattern/</link><pubDate>Mon, 21 Aug 2023 16:24:34 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_pipeline_pattern/</guid><description>Yet another Go concurrency pattern! This particular pattern is extremely helpful in composing several transformations from data incoming from a stream, and is know as the pipeline concurrency pattern. In a pipeline, we define several stages, which are nothing more than objects that take data in, perform some operation on it, and then output the transformed data.
Link to the code https://github.com/ornlu-is/go_pipeline_pattern The Pipeline pattern in Go Pipeline pattern Translating the above definition to Go, the pipeline pattern is simply a function that takes a channel, performs some operation on the data from that channel, and outputs it to another channel.</description></item><item><title>Go Concurrency Patterns: Fan-Out</title><link>https://ornlu-is.github.io/go_fan_out_pattern/</link><pubDate>Mon, 21 Aug 2023 14:40:12 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_fan_out_pattern/</guid><description>I have written a blog post about the fan-in concurrency pattern and, unlike most texts on this matter, I left its counterpart, the fan-out concurrency pattern, to have its own post. While these two patterns are mostly used in tandem, I believe that it is fundamental to understand them separately, so as to not create any mental blockers that would coherce us to only use one pattern when the other is also required.</description></item></channel></rss>