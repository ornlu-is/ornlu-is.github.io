<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-G300HG9GRT"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G300HG9GRT")</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>A deep dive on Golang slices - Luís Franco</title><meta name=Description content="A deep dive on the internals of Go slices"><meta property="og:title" content="A deep dive on Golang slices">
<meta property="og:description" content="A deep dive on the internals of Go slices"><meta property="og:type" content="article"><meta property="og:url" content="https://ornlu-is.github.io/go_slices/"><meta property="og:image" content="https://ornlu-is.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-14T21:50:02+01:00"><meta property="article:modified_time" content="2023-08-15T14:52:32+01:00"><meta property="og:site_name" content="Super website"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ornlu-is.github.io/logo.png"><meta name=twitter:title content="A deep dive on Golang slices"><meta name=twitter:description content="A deep dive on the internals of Go slices"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://ornlu-is.github.io/go_slices/><link rel=prev href=https://ornlu-is.github.io/netflow_v5/><link rel=next href=https://ornlu-is.github.io/kubernetes_deploy_job_failed_but_my_service_was_deployed/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"A deep dive on Golang slices","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ornlu-is.github.io\/go_slices\/"},"genre":"posts","wordcount":1534,"url":"https:\/\/ornlu-is.github.io\/go_slices\/","datePublished":"2023-08-14T21:50:02+01:00","dateModified":"2023-08-15T14:52:32+01:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Luís Franco"},"description":"A deep dive on the internals of Go slices"}</script></head><body data-header-desktop=auto data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Luís Franco">Luís Franco</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/about/>About </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></span></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Luís Franco">Luís Franco</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/about/ title>About</a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">A deep dive on Golang slices</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Luís Franco</a>
</span>&nbsp;<span class=post-category>included in <a href=/categories/golang/><i class="far fa-folder fa-fw" aria-hidden=true></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-08-14>2023-08-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1534 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;8 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#but-first-arrays>But first, arrays</a></li><li><a href=#what-is-a-slice-in-go>What is a slice in Go?</a></li><li><a href=#initialising-slices>Initialising slices</a></li><li><a href=#growing-slices-and-why-you-should-initialise-them-with-make>Growing slices and why you should initialise them with <code>make</code></a></li><li><a href=#reslicing-aka-how-youll-probably-shoot-yourself-in-the-foot>Reslicing, a.k.a., how you&rsquo;ll probably shoot yourself in the foot</a></li><li><a href=#using-copy>Using <code>copy</code></a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class=content id=content><p>Slices are Go&rsquo;s bread and butter. However, more often than not, small mistakes happen because it isn&rsquo;t exactly clear what actually is a slice. Since they are so prevalent in Go code, I decided to dive a bit deeper into their internal structure, how they are handled in different situations, and how some of the issues that arise can be avoided.</p><h2 id=but-first-arrays>But first, arrays</h2><p>Before diving into slices, it is important to know that Go also has the concept of arrays. An array is basically a numbered sequence of elements of the same type, known as the element type, and are useful when you are sure of how many memory positions you require. You can declare an array in the following ways.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>y</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>z</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The first example creates an array of size three with all its elements initialised as the element type&rsquo;s default value. One very important detail here is that the size of an array is part of its type, which consequently means that you cannot specify an array&rsquo;s size via a variable because its type must be resolved at compile time, and it also means that you cannot write functions that work with arrays of any size. The second example creates an array of size three with the given values and the last example foregoes the explicit integer specification of the array&rsquo;s size in detriment of inferring it from the number of elements in the given slice literal.</p><p>The last two details that we should be aware when working with arrays is that, in Go, arrays are values, which means that if you assign one array to another, you are copying all of its elements. Moreover, arrays in Go are comparable, meaning you can write the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>y</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=nx>y</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=what-is-a-slice-in-go>What is a slice in Go?</h2><p>In Go, arrays are rarely used and are primarily a building block for the concept of slices. So&mldr; what are slices? A slice isn&rsquo;t one thing, it&rsquo;s actually three things:</p><ul><li>A pointer to an underlying array;</li><li>The length of the underlying array;</li><li>And the capacity of the underlying array.</li></ul><p>When you create a slice, you declare the slice&rsquo;s element type, its length, and, optionally, its capacity. The Go runtime takes the given element type and capacity and allocates a contiguous memory segment of capable of holding a number of elements equal to the given capacity, and addresses the pointer to the beginning of this memory segment. Note that if you only specify the length and not the capacity of the slice, Go will assume that the capacity is equal to the length.</p><p>Unlike arrays, slices are not comparable except with the <code>nil</code> value, which is the default value for a slice.</p><h2 id=initialising-slices>Initialising slices</h2><p>There are a few ways one can declare a slice:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>d</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>e</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Let us go through these one by one. The first declaration uses a slice literal to initialise the slice, meaning that it creates a slice populated with the given values in the order they are presented. This will infer both the length and capacity of the slice from the number of elements in the slice literal. The second one behaves much like the first one, but we are initialising a slice with an empty slice literal, which means that, if we print out the contents of <code>b</code>, we get the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[]
</span></span></code></pre></td></tr></table></div></div><p>which is an empty slice. You might think that the third slice declaration produces a similar result to the second one, and that&rsquo;s where you&rsquo;re wrong. The third only declares a slice of integers, it does not perform any initialisation, meaning that its value is the slice default value, which is <code>nil</code>.</p><p>The last two use the built-in <code>make</code> function to create slices. When creating slices, <code>make</code> expects either two or three arguments. The first is the type of slice you are trying to create, the second is that slice&rsquo;s length, and the third is its capacity. When you use <code>make</code> to create a slice with non-zero length, keep in mind that you will be creating a slice with that number of elements with their values set to the element type&rsquo;s default value. In other words, the output of the fourth slice declaration is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[0, 0, 0]
</span></span></code></pre></td></tr></table></div></div><p>However, if you just wish to allocate the memory for a slice, you can specify zero length and some non-zero capacity, much like the last declaration. Note that this will create an empty slice, on par with the second declaration, but the underlying allocated array will have the specified capacity.</p><h2 id=growing-slices-and-why-you-should-initialise-them-with-make>Growing slices and why you should initialise them with <code>make</code></h2><p>Let us say you have a slice of integers that is currently holding the numbers <code>1</code> and <code>2</code>, and you want to add a third one. In Go, this is performed via the built-in <code>append</code> function, which takes as arguments the slice to which you wish to append new elements, and a variable number of new elements to append, and returns a copy of the resulting slice, which you tipically will use to override the original one:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>x</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>If <code>x</code> was initialised from a slice literal that had two elements, then <code>x</code> has capacity and length both equal to two. But when I appended <code>3</code> to it, it now has length three which is more than the previous capacity. Which prompts the question: so what is the role of a slice&rsquo;s capacity?</p><p>To understand this, we need to know what goes on under the hood when we append something to a slice that is already at its capacity limit. When you append to a slice, you are adding one or more values to it, and each of these values will logically increase the slice&rsquo;s length by one. The interesting bit happend when the length is already equal to the capacity. In this case, your slice has run out of space in the underlying array&rsquo;s memory to add new elements. As such, the Go runtime will allocate a new slice with larger capacity, copy the original slice to the new one, add the new elements to it, and the new slice is then returned by <code>append</code>.</p><p>Logically, these operations all take time. You are no longer just adding one element to a slice, you are creating a new slice, allocating memory, copying all elements to the new slice and only then you add a new element to it. Moreover, Go&rsquo;s garbage collector will now have the additional task of freeing up the memory used by the old slice. As such, it is a good practice to create a slice with an upper bound on its capacity whenever possible:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>upperBound</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>This will avoid performing all the aforementioned extra computations and help you squeeze a tiny bit more of performance from your application.</p><h2 id=reslicing-aka-how-youll-probably-shoot-yourself-in-the-foot>Reslicing, a.k.a., how you&rsquo;ll probably shoot yourself in the foot</h2><p>One operation on slices that is supported in Go is the slicing operation. This allows you to obtain a subset of a given slice:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>  <span class=c1>// [1, 2, 3, 4]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>y</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span>              <span class=c1>// [1, 2]
</span></span></span></code></pre></td></tr></table></div></div><p>But there is one caveat with slicing: it does not create a copy of the data. Instead, the new slice object created by slicing has a new length, but the same capacity as the original slice and its pointer is pointing to an element of the same underlying array. This effectively means that if you rewrite one of the elements of <code>y</code>, <em>e.g.</em>, <code>y[1]=666</code>, it will also change the element in the same position for <code>x</code>. And the same holds true if you take a slice of a slice of a slice (and so on).</p><p>Slicing is a powerful tool, but must be used with care, espectially when performing value assignments, since it might result in some unexpected behaviour.</p><h2 id=using-copy>Using <code>copy</code></h2><p>We have seen slicing as a way of copying parts of a slice and potentially shoot ourselves in the foot. The obvious question that arises is: how can I safely copy the contents of a slice, to another slice, without having to deal will all these pointer shenanigans? Go has got your back with the built-in <code>copy</code> function.</p><p>This function takes two arguments, a destination slice and a source slice, and copies as many elements of the source slice to the destination slice as the destination slice&rsquo;s length allows. Additionally, it also returns the number of copied elements.</p><p>For example, if you want to copy just the first two elements of a given slice into an entirely independent slice, you&rsquo;d simply write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>y</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>_</span> <span class=p>=</span> <span class=nb>copy</span><span class=p>(</span><span class=nx>y</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Now you can freely manipulate <code>y</code> without having to worry about what will happen to <code>x</code>.</p><h2 id=references>References</h2><ul><li><a href=https://go.dev/ref/spec#Slice_types target=_blank rel="noopener noreffer">https://go.dev/ref/spec#Slice_types</a></li><li><a href=https://go.dev/blog/slices-intro target=_blank rel="noopener noreffer">https://go.dev/blog/slices-intro</a></li><li><a href=https://go.dev/doc/effective_go#slices target=_blank rel="noopener noreffer">https://go.dev/doc/effective_go#slices</a></li><li>Jon Bodner, <em>&ldquo;Learning Go&rdquo;</em>, O&rsquo;Reilly, 1st Edition</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-08-15</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/netflow_v5/ class=prev rel=prev title="Understanding Netflow v5"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Understanding Netflow v5</a>
<a href=/kubernetes_deploy_job_failed_but_my_service_was_deployed/ class=next rel=next title="Kubernetes deploy job failed but the service was deployed">Kubernetes deploy job failed but the service was deployed<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Luís Franco</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>