<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Study Notes - Category - Luís Franco</title><link>https://ornlu-is.github.io/categories/study-notes/</link><description>Study Notes - Category - Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 14 Jul 2023 17:48:07 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/categories/study-notes/" rel="self" type="application/rss+xml"/><item><title>Slim Docker Images via Build-step Containers</title><link>https://ornlu-is.github.io/slim_docker_images/</link><pubDate>Fri, 14 Jul 2023 17:48:07 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/slim_docker_images/</guid><description><![CDATA[Docker images are supposed to be as small as possible, containing only what is absolutely required for the application inside them to run. In this post, I&rsquo;ll go over build-step containers and how to use them with Docker. For that matter let us consider an example Go application, nothing fancy, like the one given by the code snippet below:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &#34;fmt&#34; &#34;net/http&#34; ) func rootPathHandler(w http.]]></description></item></channel></rss>