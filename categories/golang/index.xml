<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Golang - Category - Luís Franco</title><link>https://ornlu-is.github.io/categories/golang/</link><description>Golang - Category - Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 17 Aug 2023 23:22:19 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/categories/golang/" rel="self" type="application/rss+xml"/><item><title>Enforcing test coverage in Go with Makefile</title><link>https://ornlu-is.github.io/go_makefile_code_coverage/</link><pubDate>Thu, 17 Aug 2023 23:22:19 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_makefile_code_coverage/</guid><description>Makefiles are a popular way of making the development process easier, since they can be used to chain several commands that allow developers to build, test, run, etc. their code. Additionally, they can also be used to create a make-based build/test system. In this post, I&amp;rsquo;m going to cover something how to set up a Makefile rule to test Golang code and enforce test coverage, i.e., have the rule fail if a predefined test coverage threshold is not met.</description></item><item><title>Go Design Patterns: Generator</title><link>https://ornlu-is.github.io/go_design_pattern_generator/</link><pubDate>Thu, 17 Aug 2023 22:13:52 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_design_pattern_generator/</guid><description>I like the generator pattern. I hadn&amp;rsquo;t realized it, but I had already encountered this pattern before when I used to program in Python. I recently found myself requiring to loop over a large sequence of numbers. Naively, I created a slice with all the values I required and then I looped over them. However, I was not satisfied with this solution so I went digging and found the generator pattern.</description></item><item><title>Using Go build tags for defining sets of tests</title><link>https://ornlu-is.github.io/go_build_tags/</link><pubDate>Wed, 16 Aug 2023 21:37:47 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_build_tags/</guid><description>Some time ago, I was looking for a way to define a clear separation in a Go project between my unit tests and my integration tests. At the time, the solution I came up with involved creating a submodule and some Makefile shenanigans to separate these into two sets. I was unhappy with this approach, since it ended up being convoluted and prone to error as the code base evolved. However, today I recently learned about Go&amp;rsquo;s build tags that seemlessly allow me to separate my integration tests from my unit tests.</description></item><item><title>A deep dive on Golang slices</title><link>https://ornlu-is.github.io/go_slices/</link><pubDate>Mon, 14 Aug 2023 21:50:02 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_slices/</guid><description>Slices are Go&amp;rsquo;s bread and butter. However, more often than not, small mistakes happen because it isn&amp;rsquo;t exactly clear what actually is a slice. Since they are so prevalent in Go code, I decided to dive a bit deeper into their internal structure, how they are handled in different situations, and how some of the issues that arise can be avoided.
But first, arrays Before diving into slices, it is important to know that Go also has the concept of arrays.</description></item><item><title>A pre-commit git hook for running Go unit tests</title><link>https://ornlu-is.github.io/git_hooks_for_go/</link><pubDate>Mon, 31 Jul 2023 19:50:06 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/git_hooks_for_go/</guid><description>I mostly code in Go, which comes with the handy go tool. This tool has a bunch of functionalities with one of the most important (at least for me) being the ability to run tests. I love writing tests for my code because I hate being paged when I am on call. However, whenever I open a PR, sometimes I forget to run the tests locally before pushing my code and then my code ends up failing the CI builds, which overall results in a slower development process.</description></item><item><title>Detecting Vulnerabilities in Go Code</title><link>https://ornlu-is.github.io/go_detecting_vulnerabilities/</link><pubDate>Tue, 25 Jul 2023 22:29:46 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_detecting_vulnerabilities/</guid><description>When writing software, one might, accidentally (or not), ship the software with vulnerabilities, which are broadly defined as flaws or weaknesses in code that can be exploited by an attacker. We do not want to have those in our Go code so we need some way of minimizing the number of vulnerabilities our code has. Fortunately there are tools built by the Go community and team that can be leveraged for this.</description></item><item><title>Go Design Patterns: Functional Options</title><link>https://ornlu-is.github.io/go_design_pattern_functional_options/</link><pubDate>Thu, 20 Jul 2023 22:19:24 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/go_design_pattern_functional_options/</guid><description>The Functional Options pattern is a rather elegant manner of implementing a Golang struct constructor that allows for custom default values, which means that users of the API we are implementing will only need to specify the struct attribute values that the users deem that shouldn&amp;rsquo;t take their default values.
For our example, let us consider the very simple use case where we have a package named person containing a Person struct, which will look like this:</description></item></channel></rss>