<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Docker - Category - Luís Franco</title><link>https://ornlu-is.github.io/categories/docker/</link><description>Docker - Category - Luís Franco</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 11 Aug 2023 11:46:41 +0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/categories/docker/" rel="self" type="application/rss+xml"/><item><title>Hooking Promtail, Loki, and Grafana to your Docker Compose stack</title><link>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</link><pubDate>Fri, 11 Aug 2023 11:46:41 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/docker_compose_promtail_loki_grafana/</guid><description>When testing software locally, one of the main tools at a software engineer&amp;rsquo;s disposal is Docker, more particularly, the Docker Compose tool. This tool allows engineers to define and run a multi-container setup using YAML files. The vast majority of software produces a form of output known as logs, which provide information on what is happening in a running application, such as errors, possible warnings, general information, and more.
The issue with inspecting Docker Compose log messages When you run a Docker Compose setup locally, you&amp;rsquo;ll usually see all container logs being printed in rapid succession in your terminal, and, depending on the amount of logs your multi-container stack produces, this might be very difficult to navigate, reason about, and correlate log messages from different containers.</description></item><item><title>Hassle-free table creation on start up for Clickhouse Docker containers</title><link>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</link><pubDate>Mon, 07 Aug 2023 19:56:16 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/clickhouse_docker_precreated_tables/</guid><description>This is a neat little trick I learned recently. I was in need of creating a Clickhouse container to attach to another application that would write to it. And I found myself thinking: it would be really convenient if there were a way to create a Clickhouse container that already comes with a set of tables created. Most of the solutions I found only were severely convoluted and relied on scripts to make this happen, so I thought that there must surely be a better way.</description></item><item><title>Slim Docker Images via Build-step Containers</title><link>https://ornlu-is.github.io/slim_docker_images/</link><pubDate>Sat, 15 Jul 2023 17:48:07 +0100</pubDate><author>Luís Franco</author><guid>https://ornlu-is.github.io/slim_docker_images/</guid><description><![CDATA[Docker images are supposed to be as small as possible, containing only what is absolutely required for the application inside them to run. In this post, I&rsquo;ll go over build-step containers and how to use them with Docker. For that matter let us consider an example Go application, nothing fancy, like the one given by the code snippet below:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &#34;fmt&#34; &#34;net/http&#34; ) func rootPathHandler(w http.]]></description></item></channel></rss>